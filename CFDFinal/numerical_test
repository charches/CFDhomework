import numpy as np
import matplotlib.pyplot as plt
from shocktubecalc import sod

GAMMA = 1.4
EPSILON = 1e-5

def primitive_to_conserved(rho, u, p):
    U = np.zeros(3)
    U[0] = rho
    U[1] = rho * u
    U[2] = p / (GAMMA - 1) + 0.5 * rho * u ** 2
    return U

def conserved_to_primitive(U):
    rho = U[0]
    u = U[1] / U[0]
    p = (GAMMA - 1) * (U[2] - 0.5 * rho * u ** 2)
    return rho, u, p

def steger_warming(eigen_values, rho, u, c):#利用steger-warming分裂通量
    F = np.zeros(3)
    F[0] = 2 * (GAMMA - 1) * eigen_values[0] + eigen_values[1] + eigen_values[2]
    F[1] = 2 * (GAMMA - 1) * eigen_values[0] * u + (u + c) * eigen_values[1] + (u - c) * eigen_values[2]
    F[2] = (GAMMA - 1) * eigen_values[0] * u ** 2 + 0.5 * (3 - GAMMA) / (GAMMA - 1) * (eigen_values[1] + eigen_values[2]) * c ** 2 + 0.5 * eigen_values[1] * (u + c) ** 2 + 0.5 * eigen_values[2] * (u - c) ** 2
    F *= rho / (2 * GAMMA)
    return F

def Fp(U):
    rho, u, p = conserved_to_primitive(U)
    c = (GAMMA * p / rho) ** 0.5
    eigen_values = [u, u + c, u - c]
    eigen_values_p = []

    for v in eigen_values:
        v_p = (v + (np.abs(v) + EPSILON ** 2) ** 0.5) / 2
        eigen_values_p.append(v_p)
    
    Fp = steger_warming(eigen_values_p, rho, u, c)

    return Fp

def Fn(U):
    rho, u, p = conserved_to_primitive(U)
    c = (GAMMA * p / rho) ** 0.5
    eigen_values = [u, u + c, u - c]
    eigen_values_n = []

    for v in eigen_values:
        v_n = (v - (np.abs(v) + EPSILON ** 2) ** 0.5) / 2
        eigen_values_n.append(v_n)
    
    Fn = steger_warming(eigen_values_n, rho, u, c)

    return Fn

def compute_dt(U, CFL):
        N = U.shape[0]
        dt = 1e9
        dx = 1 / (N - 1)
        for i in range(N):
            rho, u, p = conserved_to_primitive(U[i])
            c = (GAMMA * p / rho) ** 0.5
            dt = min(dt, CFL * dx / (np.abs(u) + c))
        return dt

def RK3(U, dt, RHS): #三阶Runge-Kutta（heun格式）
    U1 = U + 1 / 3 * dt * RHS(U)
    U2 = U + 2 / 3 * dt * RHS(U1)
    return 1 / 4 * (U + 3 * U1) + 3 / 4 * dt * RHS(U2)

class TVD:
    def __init__(self, CFL, T):
        self.CFL = CFL
        self.T = T
    
    def minmod(self, r): #minmod限制器
        phi = np.zeros(3)
        for i in range(3):
            if r[i] < 0:
                phi[i] = 0
            elif 0 <= r[i] and r[i] < 1:
                phi[i] = r[i]
            else:
                phi[i] = 1
        return phi

    def RHS(self, U):#计算半离散后右侧表达式 
        N = U.shape[0]
        Fp = np.apply_along_axis(globals()['Fp'], axis = 1, arr = U)
        Fn = np.apply_along_axis(globals()['Fn'], axis = 1, arr = U)

        ng = 2 #TVD格式两侧各有2个ghost cell
        #计算正负数值通量
        Fp_hat = np.zeros((N - 1, 3))
        Fn_hat = np.zeros((N - 1, 3))
        for i in range(ng - 1, N - ng):
            rp = (Fp[i] - Fp[i - 1]) / (Fp[i + 1] - Fp[i] + EPSILON)
            Fp_hat[i] = Fp[i] + 0.5 * self.minmod(rp) * (Fp[i + 1] - Fp[i])

            rn = (Fn[i + 2] - Fn[i + 1]) / (Fn[i + 1] - Fn[i] + EPSILON)
            Fn_hat[i] = Fn[i + 1] - 0.5 * self.minmod(rn) * (Fn[i + 1] - Fn[i])

        #计算总体右侧表达式
        dx = 1 / (N - 1)
        RHS = np.zeros((N, 3))
        for i in range(ng, N - ng):
            RHS[i] = -(Fp_hat[i] - Fp_hat[i - 1] + Fn_hat[i] - Fn_hat[i - 1]) / dx

        return RHS
    
    def solve(self, U):#完整求解器
        N = U.shape[0]

        #初始化
        x = np.linspace(-0.5, 0.5, N)
        UL = primitive_to_conserved(1, 0, 1)
        UR = primitive_to_conserved(0.125, 0, 0.1)
        for i in range(N):
            if x[i] < 0:
                U[i] = UL
            else:
                U[i] = UR
        
        #时间推进
        t = 0
        while t <= self.T:
            dt = compute_dt(U, self.CFL)
            U = RK3(U, dt, self.RHS)
            t += dt
        
        rho = np.zeros(N)
        u = np.zeros(N)
        p = np.zeros(N)
        for i in range(N):
            rho[i], u[i], p[i] = conserved_to_primitive(U[i])

        return rho, u, p


def plot_comparison(rho, u, p, ref_data, title_suffix = ""):
    plt.figure(figsize=(12, 8))
    x = np.linspace(-0.5, 0.5, len(rho))

    # 设置颜色和线型
    num_style = {'color': 'red', 'linestyle': '-', 'linewidth': 2, 'label': 'Numerical'}
    ref_style = {'color': 'blue', 'linestyle': '--', 'linewidth': 1.5, 'label': 'Reference'}
    
    # 1. 密度对比
    plt.subplot(3, 1, 1)
    plt.plot(x, rho, **num_style)
    plt.plot(ref_data['x'], ref_data['rho'], **ref_style)
    plt.ylabel('Density (ρ)')
    plt.title(f'Solution Comparison {title_suffix}')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.axis([-0.5, 0.5, 0, 1.1])
    
    # 2. 速度对比
    plt.subplot(3, 1, 2)
    plt.plot(x, u, **num_style)
    plt.plot(ref_data['x'], ref_data['u'], **ref_style)
    plt.ylabel('Velocity (u)')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.axis([-0.5, 0.5, -0.1, 1.0])
    
    # 3. 压强对比
    plt.subplot(3, 1, 3)
    plt.plot(x, p, **num_style)
    plt.plot(ref_data['x'], ref_data['p'], **ref_style)
    plt.ylabel('Pressure (p)')
    plt.xlabel('Position (x)')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.axis([-0.5, 0.5, 0, 1.1])
    
    plt.tight_layout()
    plt.savefig(f"./pictures/Solution Comparison {title_suffix}", dpi = 300, bbox_inches = 'tight')

#基本参数设置
CFL = 0.8
T = 0.2

#参考解
_, _, values = sod.solve(left_state = (1, 1, 0), right_state = (0.1, 0.125, 0.), geometry = (-0.5, 0.5, 0), t = T, gamma = 1.4, npts = 1001)

#TVD格式（N = 501）
U = np.zeros((501, 3))
TVDsolver = TVD(CFL, T)
rho, u, p = TVDsolver.solve(U)
plot_comparison(rho, u, p, values, "(TVD Scheme, N=501)")

#TVD格式（N = 1001）
U = np.zeros((1001, 3))
TVDsolver = TVD(CFL, T)
rho, u, p = TVDsolver.solve(U)
plot_comparison(rho, u, p, values, "(TVD Scheme, N=1001)")